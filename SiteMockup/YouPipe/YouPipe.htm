<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouPipe Upload Studio</title>
    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="youpipe.css">
    <!-- Shared site stylesheet (contains .back-button) -->
    <link rel="stylesheet" href="../styles.css">
</head>
<body>

    <a href="../index.html" class="back-button" aria-label="Back to index" title="Back to index">
        <!-- Left arrow icon -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
        </svg>
    </a>

    <div class="uploader-container">
        <!-- The header mimics the YouTube logo style -->
        <div class="header">
            <span>You</span><span class="logo-box">Pipe</span>
            <span class="studio-text">Studio</span>
        </div>
        
    <h2>Upload H.265 (HEVC) video (230 MiB Limit)</h2>
        
        <!-- This label triggers the hidden file input -->
        <label for="file-input">
            <div class="upload-box" id="drop-zone">
                <div class="upload-icon">
                    <!-- Simple SVG for upload icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px" fill="#606060"><path d="M19.35 10.04C18.67 6.6 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>
                </div>
                <div class="upload-text">Drag and drop video files to upload</div>
                <div class="upload-subtext">This tool checks if your file is H.265/HEVC and under the 230 MiB limit.</div>
                
                <button type="button" class="upload-button">Select File</button>
            </div>
        </label>
        
        <!-- The actual file input, visually hidden -->
        <input type="file" id="file-input" accept="video/*">
        
        <!-- This section will show the results -->
        <div id="feedback-area">
            <h3>File Analysis Report</h3>
            <!-- Display-only properties -->
            <div class="feedback-item">
                <span>File Name:</span>
                <span id="file-name">...</span>
            </div>
            <div class="feedback-item">
                <span>File Size:</span>
                <span id="file-size">...</span>
            </div>
            <div class="feedback-item">
                <span>File Type:</span>
                <span id="file-type">...</span>
            </div>
            <div class="feedback-item">
                <span>Resolution:</span>
                <span id="file-resolution">...</span>
            </div>
            <div class="feedback-item">
                <span>Duration:</span>
                <span id="file-duration">...</span>
            </div>
             <div class="feedback-item">
                <span>Aspect Ratio:</span>
                <span id="file-aspect">...</span>
            </div>
            <div class="feedback-item">
                <span>Est. Bitrate:</span>
                <span id="file-bitrate">...</span>
            </div>
            
            <hr>
            <!-- Validation Check: Only file size matters -->
            <div class="feedback-item">
                <span>File Size (Max 230 MiB):</span>
                <span id="status-size" class="status">...</span>
            </div>
            <div class="feedback-item">
                <span>Codec (must be H.265 / HEVC):</span>
                <span id="status-codec" class="status">...</span>
            </div>
        </div>
    </div>

    <!-- Embedded JavaScript -->
    <script>
        // Get all the DOM elements
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const feedbackArea = document.getElementById('feedback-area');

        // Make the visible button open the hidden file input immediately.
        // Some browsers handle clicks on interactive elements nested within a <label>
        // differently which can cause delays. Triggering the input directly
        // on the button's click gives a consistent fast response.
        const selectButton = document.querySelector('.upload-button');
        if (selectButton) {
            selectButton.addEventListener('click', (e) => {
                // Prevent the event from bubbling to the label which may
                // cause browser-dependent behavior; rely on the explicit click.
                e.stopPropagation();
                // Programmatic click from a user gesture will open the file picker.
                fileInput.click();
            });
        }
        
        // File Info Elements
        const elFileName = document.getElementById('file-name');
        const elFileSize = document.getElementById('file-size');
        const elFileType = document.getElementById('file-type');
        const elFileRes = document.getElementById('file-resolution');
        const elFileDuration = document.getElementById('file-duration');
        const elFileAspect = document.getElementById('file-aspect');
        const elFileBitrate = document.getElementById('file-bitrate');
        
        // Status Elements
        const elStatusSize = document.getElementById('status-size');
    const elStatusCodec = document.getElementById('status-codec');

        // Listen for the user selecting a file
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                analyseFile(file);
            }
        });

        // --- Drag and Drop Functionality ---
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault(); 
            dropZone.style.borderColor = '#065fd4'; // YouTube Blue
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#ccc';
        });
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropZone.style.borderColor = '#ccc';
            const file = event.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                fileInput.files = event.dataTransfer.files;
                analyseFile(file);
            } else {
                alert("Please drop a video file.");
            }
        });
        // --- End Drag and Drop ---

        function analyseFile(file) {
            // Define the size limit: 230 MiB
            const MAX_FILE_SIZE_BYTES = 230 * 1024 * 1024; // 230 MiB

            // Make the feedback area visible
            feedbackArea.style.display = 'block';

            // 1. Check File Name, Size, and Type
            elFileName.textContent = file.name;
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
            elFileSize.textContent = `${fileSizeMB} MB`;
            
            const fileExtension = file.name.split('.').pop().toLowerCase();
            elFileType.textContent = fileExtension.toUpperCase();

            // 2. Perform the *only* validation: File Size
            if (file.size <= MAX_FILE_SIZE_BYTES) {
                elStatusSize.textContent = 'Valid';
                elStatusSize.className = 'status success';
            } else {
                elStatusSize.textContent = 'Error: File exceeds 230 MiB';
                elStatusSize.className = 'status error';
            }

            // 2b. Detect H.265 / HEVC codec (best-effort): scan initial bytes for 'hev1' or 'hvc1'
            detectHEVCFromFile(file).then(isHevc => {
                if (isHevc) {
                    elStatusCodec.textContent = 'Valid (HEVC detected)';
                    elStatusCodec.className = 'status success';
                } else {
                    elStatusCodec.textContent = 'Error: Not H.265 / HEVC';
                    elStatusCodec.className = 'status error';
                }
            });

            // 3. Get and display other metadata (for information only)
            const video = document.createElement('video');
            video.preload = 'metadata';
            const objectURL = URL.createObjectURL(file);
            video.src = objectURL;

            video.onloadedmetadata = () => {
                // Get video properties
                const width = video.videoWidth;
                const height = video.videoHeight;
                const duration = video.duration;
                
                // Calculate aspect ratio and bitrate (guard duration=0)
                const aspectRatio = (height === 0) ? 0 : (width / height);
                const bitrateMbps = (duration > 0) ? ((file.size * 8) / (duration * 1000000)) : 0;

                // Display info
                elFileRes.textContent = `${width}px x ${height}px`;
                elFileDuration.textContent = `${duration.toFixed(2)} seconds`;
                elFileAspect.textContent = (aspectRatio > 0) ? `${aspectRatio.toFixed(2)}:1` : 'N/A';
                elFileBitrate.textContent = (bitrateMbps > 0) ? `${bitrateMbps.toFixed(2)} Mbps` : 'N/A';

                // Clean up the temporary URL
                URL.revokeObjectURL(objectURL);
            };
            
            video.onerror = () => {
                elFileRes.textContent = 'N/A (Cannot read video)';
                elFileDuration.textContent = 'N/A';
                elFileAspect.textContent = 'N/A';
                elFileBitrate.textContent = 'N/A';
                URL.revokeObjectURL(objectURL); // Clean up
            };
        }

        /**
         * Best-effort detection of H.265/HEVC in the uploaded file.
         * Strategy:
         *  - Read up to the first 2 MiB of the file and search for the ASCII
         *    fourccs 'hev1' or 'hvc1' which commonly appear in MP4/ISOBMFF
         *    sample descriptions for HEVC.
         *  - This is not perfect (containers may store codec info later),
         *    so it's a heuristic. Returns a Promise<boolean>.
         */
        async function detectHEVCFromFile(file) {
            try {
                const maxRead = Math.min(file.size, 2 * 1024 * 1024); // 2 MiB
                const slice = file.slice(0, maxRead);
                const buffer = await slice.arrayBuffer();
                const bytes = new Uint8Array(buffer);

                const encoder = new TextEncoder();
                const patterns = [encoder.encode('hev1'), encoder.encode('hvc1')];

                const indexOfPattern = (haystack, needle) => {
                    if (needle.length === 0) return 0;
                    for (let i = 0; i <= haystack.length - needle.length; i++) {
                        let match = true;
                        for (let j = 0; j < needle.length; j++) {
                            if (haystack[i + j] !== needle[j]) {
                                match = false;
                                break;
                            }
                        }
                        if (match) return i;
                    }
                    return -1;
                };

                for (const p of patterns) {
                    if (indexOfPattern(bytes, p) !== -1) return true;
                }

                // Heuristic failed: try a lightweight fallback using the file's type string
                // and the browser's ability to play HEVC containers. This does NOT
                // guarantee the file is HEVC, but helps in some cases.
                if (file.type && file.type.includes('mp4')) {
                    // Ask the browser if it supports HEVC in MP4 container
                    const can = document.createElement('video').canPlayType('video/mp4; codecs="hev1"');
                    if (can === 'probably' || can === 'maybe') {
                        // We can't be sure the file itself is HEVC, so return false
                        // to require the explicit signature match above. Keep this
                        // branch for informational purposes.
                    }
                }

                return false;
            } catch (e) {
                // On any error, fail closed (treat as not HEVC)
                console.error('HEVC detection error', e);
                return false;
            }
        }
    </script>

</body>
</html>